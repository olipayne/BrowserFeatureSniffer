<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dynamic Browser Feature Detector</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-gray-100 p-8">
    <div class="max-w-6xl mx-auto">
      <h1 class="text-3xl font-bold mb-6">Dynamic Browser Feature Detector</h1>

      <div id="loading" class="bg-white rounded-lg shadow p-6 mb-6">
        <div class="animate-pulse">
          <div class="h-4 bg-gray-200 rounded w-3/4 mb-4"></div>
          <div class="h-4 bg-gray-200 rounded w-1/2"></div>
        </div>
      </div>

      <div
        class="grid grid-cols-1 md:grid-cols-2 gap-6 opacity-0 transition-opacity duration-500"
        id="results-container"
      >
        <div class="bg-white rounded-lg shadow p-6">
          <h2 class="text-xl font-semibold mb-4">Detection Results</h2>
          <div id="results" class="space-y-4">
            <div id="browser-guess" class="p-4 bg-blue-50 rounded-lg"></div>
            <div id="version-range" class="p-4 bg-green-50 rounded-lg"></div>
          </div>
        </div>

        <div class="bg-white rounded-lg shadow p-6">
          <h2 class="text-xl font-semibold mb-4">Feature Categories</h2>
          <div id="categories" class="space-y-2"></div>
        </div>
      </div>

      <div
        class="mt-6 bg-white rounded-lg shadow p-6 opacity-0 transition-opacity duration-500"
        id="features-container"
      >
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-semibold">Detailed Feature Support</h2>
          <input
            type="text"
            id="feature-search"
            placeholder="Search features..."
            class="px-4 py-2 border rounded-lg"
          />
        </div>
        <div id="features" class="space-y-2"></div>
      </div>
    </div>

    <script>
      // Helper function to flatten the compat data into testable features
      function flattenCompatData(obj, path = "") {
        const features = [];

        for (const [key, value] of Object.entries(obj)) {
          const newPath = path ? `${path}.${key}` : key;

          if (value && value.__compat) {
            const support = value.__compat.support;
            if (support) {
              features.push({
                path: newPath,
                support,
                name: value.__compat.name || key,
                mdn_url: value.__compat?.mdn_url,
              });
            }
          }

          if (value && typeof value === "object" && !value.__compat) {
            features.push(...flattenCompatData(value, newPath));
          }
        }

        return features;
      }

      // Generate a test function for a feature path
      function generateFeatureTest(path) {
        const parts = path.split(".");
        return () => {
          try {
            let obj = window;
            for (const part of parts) {
              if (part === "constructor") return false; // Skip dangerous properties
              obj = obj[part];
              if (obj === undefined) return false;
            }
            return true;
          } catch {
            return false;
          }
        };
      }

      // Process browser support data
      function processSupport(support) {
        if (Array.isArray(support)) {
          // Process all entries to find both addition and removal information
          const versions = support
            .filter(
              (s) => s.version_added !== null || s.version_removed !== null
            )
            .map((s) => ({
              added: s.version_added
                ? s.version_added.startsWith("≤")
                  ? parseFloat(s.version_added.slice(1))
                  : parseFloat(s.version_added)
                : null,
              removed: s.version_removed
                ? s.version_removed.startsWith("≤")
                  ? parseFloat(s.version_removed.slice(1))
                  : parseFloat(s.version_removed)
                : null,
              flags: s.flags || [],
              partial_implementation: s.partial_implementation || false,
            }))
            .filter((v) => !isNaN(v.added) || !isNaN(v.removed));

          return versions.length > 0 ? versions : null;
        }

        if (!support) return null;

        return [
          {
            added: support.version_added
              ? support.version_added.startsWith("≤")
                ? parseFloat(support.version_added.slice(1))
                : parseFloat(support.version_added)
              : null,
            removed: support.version_removed
              ? support.version_removed.startsWith("≤")
                ? parseFloat(support.version_removed.slice(1))
                : parseFloat(support.version_removed)
              : null,
            flags: support.flags || [],
            partial_implementation: support.partial_implementation || false,
          },
        ];
      }

      // Get the minimum version where a feature was added
      function getMinVersion(support) {
        const processed = processSupport(support);
        if (!processed || processed.version_added === null) return null;
        if (typeof processed.version_added === "string") {
          if (processed.version_added.startsWith("≤")) {
            return parseFloat(processed.version_added.slice(1));
          }
          return parseFloat(processed.version_added);
        }
        return processed.version_added;
      }

      async function initializeDetector() {
        try {
          // Fetch compatibility data
          const response = await fetch(
            "https://unpkg.com/@mdn/browser-compat-data/data.json"
          );
          const bcd = await response.json();

          // Process API features
          const apiFeatures = flattenCompatData(bcd.api).filter((feature) => {
            // Filter out features that are too deep or potentially problematic
            const depth = feature.path.split(".").length;
            return depth < 4 && !feature.path.includes("constructor");
          });

          // Generate tests for each feature
          const featureTests = {};
          apiFeatures.forEach((feature) => {
            featureTests[feature.path] = {
              test: generateFeatureTest(feature.path),
              support: feature.support,
              name: feature.name,
              mdn_url: feature.mdn_url,
            };
          });

          // Run all tests
          const results = {};
          for (const [feature, data] of Object.entries(featureTests)) {
            results[feature] = data.test();
          }

          // Process results
          const browserType = detectBrowserType();
          const versionRange = estimateVersionRange(
            results,
            featureTests,
            browserType
          );

          // Update UI
          updateUI(results, featureTests, browserType, versionRange);
        } catch (error) {
          console.error("Error initializing detector:", error);
          document.getElementById("loading").innerHTML = `
                    <div class="text-red-600">
                        Error loading browser compatibility data. Please try again later.
                    </div>
                `;
        }
      }

      function detectBrowserType() {
        const ua = navigator.userAgent.toLowerCase();
        if (ua.includes("firefox")) return "firefox";
        if (ua.includes("safari") && !ua.includes("chrome")) return "safari";
        if (ua.includes("chrome")) return "chrome";
        return "unknown";
      }

      function estimateVersionRange(results, featureTests, browserType) {
        let minVersion = 0;
        let maxVersion = getCurrentBrowserVersion(browserType);
        const versionConstraints = [];

        for (const [feature, supported] of Object.entries(results)) {
          const featureData = featureTests[feature];
          if (!featureData.support[browserType]) continue;

          const supportData = processSupport(featureData.support[browserType]);
          if (!supportData) continue;

          for (const version of supportData) {
            if (!version) continue;

            // Handle feature presence
            if (supported) {
              // If feature is present, browser version must be:
              // 1. After or equal to when it was added
              // 2. Before or equal to when it was removed (if it was removed)
              if (version.added) {
                versionConstraints.push({
                  min: version.added,
                  max: version.removed || maxVersion,
                  feature,
                  reason: "Feature present",
                });
              }
            } else {
              // If feature is not present, browser version must be:
              // 1. Before it was added OR
              // 2. After it was removed
              if (version.added && version.removed) {
                versionConstraints.push({
                  min: version.removed,
                  max: maxVersion,
                  feature,
                  reason: "Feature removed",
                });
              } else if (version.added) {
                versionConstraints.push({
                  min: 0,
                  max: version.added,
                  feature,
                  reason: "Feature not yet added",
                });
              }
            }
          }
        }

        // Find strictly overlapping version ranges
        let finalMin = 0;
        let finalMax = maxVersion;
        let strictRanges = [];

        // First, sort constraints by min version
        versionConstraints.sort((a, b) => a.min - b.min);

        // Find overlapping constraints that create strict version requirements
        versionConstraints.forEach((constraint) => {
          if (constraint.min === constraint.max) {
            // Exact version requirement
            strictRanges.push(constraint);
          } else if (
            constraint.reason === "Feature present" &&
            constraint.min > finalMin
          ) {
            finalMin = constraint.min;
            strictRanges.push(constraint);
          } else if (
            constraint.reason === "Feature not yet added" &&
            constraint.max < finalMax
          ) {
            finalMax = constraint.max;
            strictRanges.push(constraint);
          }
        });

        // If we have any exact version matches, use them to narrow the range
        const exactVersions = strictRanges.filter((r) => r.min === r.max);
        if (exactVersions.length > 0) {
          const version = exactVersions[0].min;
          finalMin = version;
          finalMax = version;
        } else {
          // Ensure min <= max
          if (finalMin > finalMax) {
            const temp = finalMin;
            finalMin = finalMax;
            finalMax = temp;
          }
        }

        // Store constraints for UI display
        window.versionConstraints = strictRanges;

        return {
          min: Math.floor(finalMin),
          max: Math.ceil(finalMax),
          constraints: versionConstraints,
        };
      }

      function getCurrentBrowserVersion(browserType) {
        const ua = navigator.userAgent;
        let match;

        switch (browserType) {
          case "chrome":
            match = ua.match(/Chrome\/(\d+\.\d+)/);
            break;
          case "firefox":
            match = ua.match(/Firefox\/(\d+\.\d+)/);
            break;
          case "safari":
            match = ua.match(/Version\/(\d+\.\d+)/);
            break;
        }

        return match ? parseFloat(match[1]) : 999;
      }

      function updateUI(results, featureTests, browserType, versionRange) {
        // Hide loading indicator
        document.getElementById("loading").style.display = "none";

        // Show results containers
        document
          .getElementById("results-container")
          .classList.remove("opacity-0");
        document
          .getElementById("features-container")
          .classList.remove("opacity-0");

        // Update browser detection results
        document.getElementById("browser-guess").innerHTML = `
                <p class="font-medium">Detected Browser: ${
                  browserType.charAt(0).toUpperCase() + browserType.slice(1)
                }</p>
            `;

        document.getElementById("version-range").innerHTML = `
                <p class="font-medium">Estimated Version Range:</p>
                <p>Version ${versionRange.min.toFixed(
                  1
                )} - ${versionRange.max.toFixed(1)}</p>
                <div class="mt-4 text-sm">
                    <p class="font-medium mb-2">Key Version Constraints:</p>
                    <div class="space-y-1 max-h-40 overflow-y-auto">
                        ${versionRange.constraints
                          .filter(
                            (c) =>
                              Math.abs(c.min - versionRange.min) < 1 ||
                              Math.abs(c.max - versionRange.max) < 1
                          )
                          .map(
                            (c) => `
                                <div class="text-xs">
                                    <span class="font-medium">${c.feature}</span>
                                    <span class="text-gray-600">
                                        (${c.reason}: v${c.min} - v${c.max})
                                    </span>
                                </div>
                            `
                          )
                          .join("")}
                    </div>
                </div>
            `;

        // Group features by meaningful categories
        const categories = {};
        Object.entries(featureTests).forEach(([path, data]) => {
          // Extract main category from path or MDN data
          const pathParts = path.split(".");
          let category;

          // Determine category based on path structure and known patterns
          if (path.includes("CSS")) {
            category = "CSS & Styling";
          } else if (path.includes("HTML")) {
            category = "HTML Features";
          } else if (path.includes("Worker")) {
            category = "Web Workers";
          } else if (
            path.includes("WebGL") ||
            path.includes("Canvas") ||
            path.includes("XR")
          ) {
            category = "Graphics & XR";
          } else if (
            path.includes("Media") ||
            path.includes("Audio") ||
            path.includes("Video")
          ) {
            category = "Media Features";
          } else if (
            path.includes("Storage") ||
            path.includes("Cache") ||
            path.includes("DB")
          ) {
            category = "Storage & Caching";
          } else if (
            path.includes("Network") ||
            path.includes("Fetch") ||
            path.includes("XHR")
          ) {
            category = "Networking";
          } else if (path.includes("Crypto") || path.includes("Security")) {
            category = "Security & Crypto";
          } else if (pathParts[0] === "api") {
            category = "Web APIs";
          } else {
            category = "Other Features";
          }

          if (!categories[category]) {
            categories[category] = {
              total: 0,
              supported: 0,
              features: [],
            };
          }

          categories[category].total++;
          if (results[path]) {
            categories[category].supported++;
          }

          // Store feature details for deeper analysis
          categories[category].features.push({
            path,
            supported: results[path],
            data: data,
          });
        });

        // Update categories display
        document.getElementById("categories").innerHTML = Object.entries(
          categories
        )
          .filter(([_, data]) => data.total > 0) // Only show categories with features
          .sort((a, b) => b[1].total - a[1].total) // Sort by number of features
          .map(([category, data]) => {
            const percentage = ((data.supported / data.total) * 100).toFixed(1);
            const features = data.features
              .sort((a, b) => b.supported - a.supported)
              .slice(0, 3); // Show top 3 features as examples

            return `
                        <div class="p-4 bg-gray-50 rounded hover:bg-gray-100 transition-colors">
                            <div class="flex justify-between items-center mb-3">
                                <div>
                                    <span class="font-medium text-lg">${category}</span>
                                    <span class="ml-2 text-sm text-gray-600">
                                        ${data.supported}/${data.total} features
                                    </span>
                                </div>
                                <span class="text-sm font-medium ${
                                  percentage > 80
                                    ? "text-green-600"
                                    : percentage > 40
                                    ? "text-yellow-600"
                                    : "text-red-600"
                                }">
                                    ${percentage}%
                                </span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2 mb-3">
                                <div class="h-2 rounded-full transition-all duration-500 ${
                                  percentage > 80
                                    ? "bg-green-500"
                                    : percentage > 40
                                    ? "bg-yellow-500"
                                    : "bg-red-500"
                                }" style="width: ${percentage}%"></div>
                            </div>
                            <div class="text-sm text-gray-600 space-y-1">
                                ${features
                                  .map(
                                    (f) => `
                                    <div class="flex items-center">
                                        <span class="${
                                          f.supported
                                            ? "text-green-500"
                                            : "text-red-500"
                                        } mr-2">
                                            ${f.supported ? "✓" : "✗"}
                                        </span>
                                        ${f.path}
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        </div>
                    `;
          })
          .join("");

        // Create the features display
        const featuresEl = document.getElementById("features");
        const featuresList = Object.entries(featureTests)
          .map(([path, data]) => {
            const supported = results[path];
            return `
                        <div class="p-2 rounded ${
                          supported ? "bg-green-50" : "bg-red-50"
                        } feature-item" 
                             data-path="${path}">
                            <div class="flex justify-between">
                                <div>
                                    <span class="font-medium">${path}</span>
                                    <span class="${
                                      supported
                                        ? "text-green-600"
                                        : "text-red-600"
                                    } ml-2">
                                        ${supported ? "✓" : "✗"}
                                    </span>
                                </div>
                                ${
                                  data.mdn_url
                                    ? `
                                    <a href="${data.mdn_url}" 
                                       target="_blank" 
                                       class="text-blue-600 hover:text-blue-800 text-sm">
                                        MDN Docs
                                    </a>
                                `
                                    : ""
                                }
                            </div>
                            ${
                              browserType in data.support
                                ? `
                                <div class="text-sm text-gray-600 mt-1">
                                    Added in version: ${
                                      getMinVersion(
                                        data.support[browserType]
                                      ) || "unknown"
                                    }
                                </div>
                            `
                                : ""
                            }
                        </div>
                    `;
          })
          .join("");

        featuresEl.innerHTML = featuresList;

        // Add search functionality
        const searchInput = document.getElementById("feature-search");
        searchInput.addEventListener("input", (e) => {
          const searchTerm = e.target.value.toLowerCase();
          document.querySelectorAll(".feature-item").forEach((item) => {
            const path = item.dataset.path.toLowerCase();
            item.style.display = path.includes(searchTerm) ? "block" : "none";
          });
        });
      }

      // Initialize when page loads
      window.addEventListener("load", initializeDetector);
    </script>
  </body>
</html>
